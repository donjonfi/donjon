import { EClasseRacine } from "../models/commun/constantes";
import { Genre } from "../models/commun/genre.enum";
import { Nombre } from "../models/commun/nombre.enum";
import { ContexteAnalyse } from "../models/compilateur/contexte-analyse";
import { Definition } from "../models/compilateur/definition";
import { PositionSujetString } from "../models/compilateur/position-sujet";
import { ResultatAnalysePhrase } from "../models/compilateur/resultat-analyse-phrase";
import { Analyseur } from "../utils/compilation/analyseur/analyseur";
import { AnalyseurElementPosition } from "../utils/compilation/analyseur/analyseur.element.position";
import { AnalyseurElementSimple } from "../utils/compilation/analyseur/analyseur.element.simple";
import { AnalyseurType } from "../utils/compilation/analyseur/analyseur.type";
import { AnalyseurUtils } from "../utils/compilation/analyseur/analyseur.utils";
import { Compilateur } from "../utils/compilation/compilateur";

describe('Analyseur âˆ’ DÃ©finition de nouveaux Ã©lÃ©ments', () => {

    // =========================================================
    // Ã‰LÃ‰MENTS SANS POSITION
    // =========================================================

    it('Ã‰lÃ©ment sans pos: Â«â€¯La cuisine est un lieu.â€¯Â»', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "La cuisine est un lieu."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.elementSansPosition);
        // tester lâ€™analyse spÃ©cifique
        const el = AnalyseurElementSimple.testerElementSansPosition(phrases[0], ctxAnalyse); // analyser phrase
        expect(el).not.toBeNull(); // Ã©lÃ©ment trouvÃ©
        ctxAnalyse.dernierElementGenerique = el; // dernier Ã©lÃ©ment trouvÃ©
        expect(el.determinant).toEqual('la '); // dÃ©terminant
        expect(el.nom).toEqual('cuisine'); // nom
        expect(el.epithete).toBeUndefined(); // Ã©pithÃ¨te pas dÃ©fini
        expect(el.genre).toEqual(Genre.f); // genre
        expect(el.nombre).toEqual(Nombre.s); // nombre
        expect(el.quantite).toEqual(1); // quantitÃ©
        expect(el.classeIntitule).not.toBeNull(); // intitulÃ© classe dÃ©fini
        expect(el.classeIntitule).toEqual(EClasseRacine.lieu); // intitulÃ© classe
        expect(el.positionString).toBeNull(); // position pas dÃ©finie
        AnalyseurUtils.ajouterDescriptionDernierElement(phrases[0], ctxAnalyse); // ajout description Ã©ventuelle
        expect(el.description).toBeNull(); // desrcription pas dÃ©finie
        expect(el.capacites).toHaveSize(0); // aucune capacitÃ©
        expect(el.attributs).toHaveSize(0); // aucun attribut
        expect(el.proprietes).toHaveSize(0); // aucune propriÃ©tÃ©
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    it('Ã‰lÃ©ment sans pos: Â«â€¯Paris (f) est un lieu gris. "Vous Ãªtes dans Paris.".â€¯Â»', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            'Paris (f) est un lieu gris. "Vous Ãªtes dans Paris.".'
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(2); // 2 morceaux
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.elementSansPosition);
        // tester lâ€™analyse spÃ©cifique
        const el = AnalyseurElementSimple.testerElementSansPosition(phrases[0], ctxAnalyse); // analyser phrase
        expect(el).not.toBeNull(); // Ã©lÃ©ment trouvÃ©
        ctxAnalyse.dernierElementGenerique = el; // dernier Ã©lÃ©ment trouvÃ©
        expect(el.determinant).toBeNull(); // dÃ©terminant
        expect(el.nom).toEqual('Paris'); // nom
        expect(el.epithete).toBeUndefined(); // Ã©pithÃ¨te pas dÃ©fini
        expect(el.genre).toEqual(Genre.f); // genre
        expect(el.nombre).toEqual(Nombre.s); // nombre
        expect(el.quantite).toEqual(1); // quantitÃ©
        expect(el.classeIntitule).not.toBeNull(); // intitulÃ© classe dÃ©fini
        expect(el.classeIntitule).toEqual(EClasseRacine.lieu); // intitulÃ© classe
        expect(el.positionString).toBeNull(); // position pas dÃ©finie
        AnalyseurUtils.ajouterDescriptionDernierElement(phrases[0], ctxAnalyse); // ajout description Ã©ventuelle
        expect(el.description).toBe('Vous Ãªtes dans Paris.'); // desrcription dÃ©finie
        expect(el.capacites).toHaveSize(0); // aucune capacitÃ©
        expect(el.attributs).toHaveSize(1); // aucun attribut
        expect(el.proprietes).toHaveSize(0); // aucune propriÃ©tÃ©
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    it('Ã‰lÃ©ment sans pos: Â«â€¯La chÃ¢teau du comte est un lieu au nord du village.â€¯Â» (ðŸ’¥)', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "La chÃ¢teau du comte est un lieu au nord du village."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.elementAvecPosition);
        // tester lâ€™analyse spÃ©cifique
        const resultat = AnalyseurElementSimple.testerElementSansPosition(phrases[0], ctxAnalyse);
        expect(resultat).toBeNull(); // rÃ©sultat PAS trouvÃ©.
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    it('Ã‰lÃ©ment sans pos: Â«â€¯Un lutin est une personne.â€¯Â» (ðŸ’¥)', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Un lutin est une personne."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.type);
        // tester lâ€™analyse spÃ©cifique
        const resultat = AnalyseurElementSimple.testerElementSansPosition(phrases[0], ctxAnalyse);
        expect(resultat).toBeNull(); // rÃ©sultat PAS trouvÃ©.
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });


    // =========================================================
    // Ã‰LÃ‰MENT AVEC POSITION
    // =========================================================


    it('Ã‰lÃ©ment pos: Â«â€¯Le chÃ¢teau du comte est un lieu au nord du village.â€¯Â»', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Le chÃ¢teau du comte est un lieu au nord du village."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.elementAvecPosition);
        // tester lâ€™analyse spÃ©cifique
        const el = AnalyseurElementPosition.testerElementAvecPosition(phrases[0], ctxAnalyse); // analyser phrase
        expect(el).not.toBeNull(); // Ã©lÃ©ment trouvÃ©
        ctxAnalyse.dernierElementGenerique = el; // dernier Ã©lÃ©ment trouvÃ©
        expect(el.determinant).toEqual('le '); // dÃ©terminant
        expect(el.nom).toEqual('chÃ¢teau du comte'); // nom de lâ€™Ã©lÃ©ment
        expect(el.epithete).toBeUndefined(); // Ã©pithÃ¨te pas dÃ©fini
        expect(el.genre).toEqual(Genre.m); // genre
        expect(el.nombre).toEqual(Nombre.s); // nombre
        expect(el.quantite).toEqual(1); // quantitÃ©
        expect(el.classeIntitule).not.toBeNull(); // intitulÃ© classe dÃ©fini
        expect(el.classeIntitule).toEqual(EClasseRacine.lieu); // intitulÃ© classe
        expect(el.positionString).not.toBeNull(); // position dÃ©finie
        expect(el.positionString).toEqual(new PositionSujetString('chÃ¢teau du comte', 'village', 'au nord du ')); // position
        AnalyseurUtils.ajouterDescriptionDernierElement(phrases[0], ctxAnalyse); // ajout description Ã©ventuelle
        expect(el.description).toBeNull(); // desrcription pas dÃ©finie
        expect(el.capacites).toHaveSize(0); // aucune capacitÃ©
        expect(el.attributs).toHaveSize(0); // aucun attribut
        expect(el.proprietes).toHaveSize(0); // aucune propriÃ©tÃ©
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });


    it('Ã‰lÃ©ment pos: Â«â€¯Lâ€™abri est un lieu sombre.â€¯Â» (ðŸ’¥)', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Lâ€™abri est un lieu sombre."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.elementSansPosition);
        // tester lâ€™analyse spÃ©cifique
        const resultat = AnalyseurElementPosition.testerElementAvecPosition(phrases[0], ctxAnalyse);
        expect(resultat).toBeNull(); // rÃ©sultat PAS trouvÃ©.
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });
});

describe('Analyseur âˆ’ DÃ©finition de nouveaux types', () => {


    // =========================================================
    // NOUVEAUX TYPES
    // =========================================================

    it('Nouveau typeâ€¯: Â«â€¯Un meuble est un objet.â€¯Â» ', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Un meuble est un objet."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.type);
        // tester lâ€™analyse spÃ©cifique
        ctxAnalyse = new ContexteAnalyse(); // (raz contexte)
        const resultat = AnalyseurType.testerNouveauType(phrases[0], ctxAnalyse);
        expect(resultat).toEqual(ResultatAnalysePhrase.type); // trouvÃ© un nouveau type
        expect(ctxAnalyse.typesUtilisateur).toHaveSize(1); // nouveau type ajoutÃ©
        expect(ctxAnalyse.typesUtilisateur.has('meuble')).toBeTrue(); // nouveau type retrouvÃ©
        expect(ctxAnalyse.typesUtilisateur.get('meuble').intitule).toBe('meuble'); // intitulÃ©
        expect(ctxAnalyse.typesUtilisateur.get('meuble').nombre).toBe(Nombre.s); // nombre
        expect(ctxAnalyse.typesUtilisateur.get('meuble').typeParent).toBe('objet'); // type parent
        expect(ctxAnalyse.typesUtilisateur.get('meuble').etats).toHaveSize(0); // aucun attribut spÃ©cifique
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    it('Nouveau typeâ€¯: Â«â€¯Une fÃ©e est une personne magique.â€¯Â» ', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Une fÃ©e est une personne magique."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.type);
        // tester lâ€™analyse spÃ©cifique
        ctxAnalyse = new ContexteAnalyse(); // (raz contexte)
        const resultat = AnalyseurType.testerNouveauType(phrases[0], ctxAnalyse);
        expect(resultat).toEqual(ResultatAnalysePhrase.type); // trouvÃ© un nouveau type
        expect(ctxAnalyse.typesUtilisateur).toHaveSize(1); // nouveau type ajoutÃ©
        expect(ctxAnalyse.typesUtilisateur.has('fÃ©e')).toBeTrue(); // nouveau type retrouvÃ©
        expect(ctxAnalyse.typesUtilisateur.get('fÃ©e').intitule).toBe('fÃ©e'); // intitulÃ©
        expect(ctxAnalyse.typesUtilisateur.get('fÃ©e').nombre).toBe(Nombre.s); // nombre
        expect(ctxAnalyse.typesUtilisateur.get('fÃ©e').typeParent).toBe('personne'); // type parent
        expect(ctxAnalyse.typesUtilisateur.get('fÃ©e').etats).toHaveSize(1); // attribut spÃ©cifique dÃ©fini
        expect(ctxAnalyse.typesUtilisateur.get('fÃ©e').etats[0]).toBe('magique'); // attribut spÃ©cifique
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    it('Nouveau typeâ€¯: Â«â€¯Une fÃ©e est magique.â€¯Â» (ðŸ’¥)', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Une fÃ©e est magique."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.precisionType);
        // tester lâ€™analyse spÃ©cifique      
        ctxAnalyse = new ContexteAnalyse(); // (raz contexte)
        const resultat = AnalyseurType.testerNouveauType(phrases[0], ctxAnalyse);
        expect(resultat).toEqual(ResultatAnalysePhrase.aucun); // pas trouvÃ© un nouveau type
        expect(ctxAnalyse.typesUtilisateur).toHaveSize(0); // pas de nouveau type ajoutÃ©
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });


    it('Nouveau typeâ€¯: Â«â€¯La fÃ©e est une personne.â€¯Â» (ðŸ’¥)', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "La fÃ©e est une personne."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.elementSansPosition);
        // tester lâ€™analyse spÃ©cifique
        ctxAnalyse = new ContexteAnalyse(); // (raz contexte)
        const resultat = AnalyseurType.testerNouveauType(phrases[0], ctxAnalyse);
        expect(resultat).toEqual(ResultatAnalysePhrase.aucun); // pas trouvÃ© un nouveau type
        expect(ctxAnalyse.typesUtilisateur).toHaveSize(0); // pas de nouveau type ajoutÃ©
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    // =========================================================
    // PRÃ‰CISIONS TYPES
    // =========================================================

    it('PrÃ©cision typeâ€¯: Â«â€¯Une statue est fixÃ©e.â€¯Â» ', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Une statue est fixÃ©e."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.precisionType);
        // tester lâ€™analyse spÃ©cifique
        ctxAnalyse = new ContexteAnalyse(); // (raz contexte)
        const resultat = AnalyseurType.testerPrecisionType(phrases[0], ctxAnalyse);
        expect(resultat).toEqual(ResultatAnalysePhrase.precisionType); // trouvÃ© un nouveau type
        expect(ctxAnalyse.typesUtilisateur).toHaveSize(1); // nouveau type ajoutÃ©
        expect(ctxAnalyse.typesUtilisateur.has('statue')).toBeTrue(); // nouveau type retrouvÃ©
        expect(ctxAnalyse.typesUtilisateur.get('statue').intitule).toBe('statue'); // intitulÃ©
        expect(ctxAnalyse.typesUtilisateur.get('statue').nombre).toBe(Nombre.s); // nombre
        expect(ctxAnalyse.typesUtilisateur.get('statue').typeParent).toBe('objet'); // type parent
        expect(ctxAnalyse.typesUtilisateur.get('statue').etats).toHaveSize(1); // attribut spÃ©cifique
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    it('PrÃ©cision typeâ€¯: Â«â€¯Un lutin est bavard, farceur et petit.â€¯Â» ', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Un lutin est bavard, farceur et petit."
        );
        expect(phrases).toHaveSize(1); // 1 phrase
        expect(phrases[0].phrase).toHaveSize(1); // 1 morceau
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.precisionType);
        // tester lâ€™analyse spÃ©cifique
        // -> raz contexte
        ctxAnalyse = new ContexteAnalyse();
        // -> prÃ©-remplir avec le type Â« lutin Â» qui hÃ©rite de personne
        ctxAnalyse.typesUtilisateur.set('lutin', new Definition('lutin', 'personne', Nombre.s, ['gentil']));
        const resultat = AnalyseurType.testerPrecisionType(phrases[0], ctxAnalyse);
        expect(resultat).toEqual(ResultatAnalysePhrase.precisionType); // trouvÃ© un nouveau type
        expect(ctxAnalyse.typesUtilisateur).toHaveSize(1); // pas de nouveau type ajoutÃ©
        expect(ctxAnalyse.typesUtilisateur.has('lutin')).toBeTrue(); // type existant retrouvÃ©
        expect(ctxAnalyse.typesUtilisateur.get('lutin').intitule).toBe('lutin'); // intitulÃ©
        expect(ctxAnalyse.typesUtilisateur.get('lutin').nombre).toBe(Nombre.s); // nombre
        expect(ctxAnalyse.typesUtilisateur.get('lutin').typeParent).toBe('personne'); // type parent
        expect(ctxAnalyse.typesUtilisateur.get('lutin').etats).toHaveSize(4); // attributs spÃ©cifiques (1 + 3)
        expect(ctxAnalyse.erreurs).toHaveSize(0); // aucune erreur

    });

    it('PrÃ©cision typeâ€¯: Type dÃ©fini 2x doit gÃ©nÃ©rer erreur', () => {
        let ctxAnalyse = new ContexteAnalyse();
        let phrases = Compilateur.convertirCodeSourceEnPhrases(
            "Un lutin est une personne farceuse. Un lutin est une crÃ©ature-magique aimable."
        );
        expect(phrases).toHaveSize(2); // 2 phrases
        // tester lâ€™analyse complÃ¨te
        expect(Analyseur.analyserPhrase(phrases[0], ctxAnalyse)).toBe(ResultatAnalysePhrase.type);
        expect(Analyseur.analyserPhrase(phrases[1], ctxAnalyse)).toBe(ResultatAnalysePhrase.type);
        expect(ctxAnalyse.typesUtilisateur).toHaveSize(1); // 1 nouveau type ajoutÃ© (et pas 2)
        expect(ctxAnalyse.typesUtilisateur.has('lutin')).toBeTrue(); // type existant retrouvÃ©
        expect(ctxAnalyse.typesUtilisateur.get('lutin').intitule).toBe('lutin'); // intitulÃ©
        expect(ctxAnalyse.typesUtilisateur.get('lutin').nombre).toBe(Nombre.s); // nombre
        expect(ctxAnalyse.typesUtilisateur.get('lutin').typeParent).toBe('crÃ©ature-magique'); // type parent
        expect(ctxAnalyse.typesUtilisateur.get('lutin').etats).toHaveSize(2); // attributs spÃ©cifiques (1+1)
        expect(ctxAnalyse.erreurs).toHaveSize(1); // 1 erreur a Ã©tÃ© gÃ©nÃ©rÃ©e
    });

});