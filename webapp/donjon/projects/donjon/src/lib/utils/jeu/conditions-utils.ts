import { EClasseRacine, EEtatsBase } from '../../models/commun/constantes';
import { ELocalisation, Localisation } from '../../models/jeu/localisation';
import { ElementsJeuUtils, TypeSujet } from '../commun/elements-jeu-utils';

import { AleatoireUtils } from './aleatoire-utils';
import { AnalyseurCondition } from '../compilation/analyseur/analyseur.condition';
import { ClasseUtils } from '../commun/classe-utils';
import { ClassesRacines } from '../../models/commun/classes-racines';
import { Compteur } from '../../models/compilateur/compteur';
import { CompteursUtils } from './compteurs-utils';
import { ConditionMulti } from '../../models/compilateur/condition-multi';
import { ConditionSolo } from '../../models/compilateur/condition-solo';
import { ContexteTour } from '../../models/jouer/contexte-tour';
import { ElementJeu } from '../../models/jeu/element-jeu';
import { Evenement } from '../../models/jouer/evenement';
import { ExprReg } from '../compilation/expr-reg';
import { GroupeNominal } from '../../models/commun/groupe-nominal';
import { InstructionsUtils } from './instructions-utils';
import { Intitule } from '../../models/jeu/intitule';
import { Jeu } from '../../models/jeu/jeu';
import { LienCondition } from '../../models/compilateur/lien-condition';
import { Lieu } from '../../models/jeu/lieu';
import { Liste } from '../../models/jeu/liste';
import { Objet } from '../../models/jeu/objet';
import { PhraseUtils } from '../commun/phrase-utils';
import { RechercheUtils } from '../commun/recherche-utils';
import { TypeValeur } from '../../models/compilateur/type-valeur';

export class ConditionsUtils {

  constructor(
    private jeu: Jeu,
    private verbeux: boolean,
  ) {
    this.eju = new ElementsJeuUtils(jeu, verbeux);
  }

  /** Utilitaires - √âl√©ments du jeu */
  private eju: ElementsJeuUtils;


  /** V√©rifier la condition (multi) */
  siEstVrai(conditionBrute: string | undefined, conditionMulti: ConditionMulti | undefined, contexteTour: ContexteTour, evenement: Evenement | undefined, declenchements: number | undefined): boolean {

    let resultatFinal: boolean = false;

    // si condition toujours brute, r√©cup√©rer la condition multi correspondante.
    if (!conditionMulti) {
      conditionMulti = AnalyseurCondition.getConditionMulti(conditionBrute);
    }

    // console.warn("conditionBrute:‚ÄØ", conditionBrute, "\nconditionMulti:", conditionMulti);


    // s‚Äôil s‚Äôagit d‚Äôune condition simple
    if (conditionMulti.condition) {
      resultatFinal = this.siEstVraiSansLien(null, conditionMulti.condition, contexteTour, evenement, declenchements);
      // sinon il s‚Äôagit d‚Äôune condition compos√©e
    } else if (conditionMulti.sousConditions?.length) {
      switch (conditionMulti.typeLienSousConditions) {
        // A) ET
        case LienCondition.et:
          let toutVrai = true;
          for (let indexEt = 0; indexEt < conditionMulti.sousConditions.length; indexEt++) {
            if (!this.siEstVrai(null, conditionMulti.sousConditions[indexEt], contexteTour, evenement, declenchements)) {
              toutVrai = false;
              break;
            }
          }
          resultatFinal = toutVrai;
          break;

        // B) OU (ou inclusif)
        case LienCondition.ou:
          let unVrai = false;
          for (let indexOu = 0; indexOu < conditionMulti.sousConditions.length; indexOu++) {
            if (this.siEstVrai(null, conditionMulti.sousConditions[indexOu], contexteTour, evenement, declenchements)) {
              unVrai = true;
              break;
            }
          }
          resultatFinal = unVrai;
          break;

        // C) SOIT (ou exclusif)
        case LienCondition.soit:
          let nbVrai = 0;
          for (let indexSoit = 0; indexSoit < conditionMulti.sousConditions.length; indexSoit++) {
            if (this.siEstVrai(null, conditionMulti.sousConditions[indexSoit], contexteTour, evenement, declenchements)) {
              nbVrai += 1;
              if (nbVrai > 1) {
                break;
              }
            }
          }
          resultatFinal = (nbVrai === 1);
          break;

        default:
          console.error("siEstVrai > typeLien pas pris en charge (et|ou|soit sont pris en charge) > ", conditionMulti.typeLienSousConditions);
          break;
      }
    } else {
      console.error("siEstVrai > condition et/ou sous-conditions non trouv√©es");
    }

    if (this.verbeux) {
      if (conditionBrute) {
        console.log("üîÄ ¬´ " + conditionBrute + " ¬ª\n => " + (resultatFinal ? "üôÜ‚Äç‚ôÇÔ∏è " : "üôÖ ") + resultatFinal + (contexteTour ? ("\nceci: " + contexteTour.ceci + "\ncela: " + contexteTour.cela) : ""));
      } else if (conditionMulti) {
        console.log("üîÄ ¬´ " + conditionMulti.toString() + " ¬ª\n => " + (resultatFinal ? "üôÜ‚Äç‚ôÇÔ∏è " : "üôÖ ") + resultatFinal + (contexteTour ? ("\nceci: " + contexteTour.ceci + "\ncela: " + contexteTour.cela) : ""));
      } else {
        console.error("üîÄ ni conditionBrute ni conditionMulti ici ! ")
      }
    }

    return resultatFinal;
  }


  private trouverSujetCondition(condition: ConditionSolo | undefined, contexteTour: ContexteTour, evenement: Evenement | undefined, declenchements: number | undefined): ElementJeu | Intitule | null {

    let sujet: ElementJeu | Intitule | null = null;

    const conditionSujetNomNettoye = RechercheUtils.transformerCaracteresSpeciauxEtMajuscules(condition.sujet.nom);

    if (condition.sujet) {
      // ici
      if (conditionSujetNomNettoye === 'ici') {
        sujet = this.eju.curLieu;
        // ceci
      } else if (conditionSujetNomNettoye === 'ceci') {
        sujet = contexteTour.ceci;
        if (!contexteTour.ceci) {
          console.warn("siEstVraiSansLien: le ¬´ ceci ¬ª de la condition est null.");
        }
        // cela
      } else if (conditionSujetNomNettoye === 'cela') {
        sujet = contexteTour.cela;
        if (!contexteTour.cela) {
          console.warn("siEstVraiSansLien: le ¬´ cela ¬ª de la condition est null.");
        }
        // quantit√©Ceci
      } else if (conditionSujetNomNettoye === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('quantit√©Ceci')) {
        const cpt = new Compteur("quantit√©Ceci", evenement.quantiteCeci);
        sujet = cpt;
        if (!contexteTour.ceci) {
          console.warn("siEstVraiSansLien: quantit√©Ceci: le ¬´ ceci ¬ª de la condition est null.");
        }
        // quantit√©Cela
      } else if (conditionSujetNomNettoye === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('quantit√©Cela')) {
        const cpt = new Compteur("quantit√©Cela", evenement.quantiteCela);
        sujet = cpt;
        if (!contexteTour.cela) {
          console.warn("siEstVraiSansLien: quantit√©Cela: le ¬´ cela ¬ª de la condition est null.");
        }
        // quantit√© de ceci
      } else if (conditionSujetNomNettoye === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('quantit√© de ceci')) {
        if (!contexteTour.ceci || !ClasseUtils.heriteDe(contexteTour.ceci.classe, EClasseRacine.element)) {
          console.warn("siEstVraiSansLien: quantit√© de ceci: le ¬´ ceci ¬ª de la condition est null.");
        } else {
          const cpt = new Compteur("quantit√© de ceci", (contexteTour.ceci as ElementJeu).quantite);
          sujet = cpt;
        }
        // quantit√© de cela
      } else if (conditionSujetNomNettoye === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('quantit√© de cela')) {
        if (!contexteTour.cela || !ClasseUtils.heriteDe(contexteTour.cela.classe, EClasseRacine.element)) {
          console.warn("siEstVraiSansLien: quantit√© de cela: le ¬´ cela ¬ª de la condition n‚Äôest pas un √©l√©ment.");
        } else {
          const cpt = new Compteur("quantit√© de cela", (contexteTour.cela as ElementJeu).quantite);
          sujet = cpt;
        }
        // pr√©position ceci
      } else if (condition.sujet.nom.match(/pr(?:√©|e)position (?:de )?ceci/i)) {
        sujet = new Intitule(evenement.prepositionCeci, new GroupeNominal(null, evenement.prepositionCeci, null), ClassesRacines.Intitule);
        // pr√©position cela
      } else if (condition.sujet.nom.match(/pr(?:√©|e)position (?:de )?cela/i)) {
        sujet = new Intitule(evenement.prepositionCela, new GroupeNominal(null, evenement.prepositionCela, null), ClassesRacines.Intitule);
        // origine
      } else if (conditionSujetNomNettoye === 'origine') {
        sujet = contexteTour.origine;
        if (!contexteTour.origine) {
          console.warn("siEstVraiSansLien: le ¬´ origine ¬ª de la condition est null.");
        }
        // origine
      } else if (conditionSujetNomNettoye === 'destination') {
        sujet = contexteTour.destination;
        if (!contexteTour.destination) {
          console.warn("siEstVraiSansLien: le ¬´ destination ¬ª de la condition est null.");
        }
        // orientation
      } else if (conditionSujetNomNettoye === 'orientation') {
        sujet = contexteTour.orientation;
        if (!contexteTour.orientation) {
          console.warn("siEstVraiSansLien: le ¬´ orientation ¬ª de la condition est null.");
        }
        // r√©ponse (au dernier choisir)
      } else if (conditionSujetNomNettoye === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('r√©ponse')) {
        if (!contexteTour.reponse) {
          this.eju.ajouterConseil("Condition sur ¬´ r√©ponse ¬ª : il n‚Äôy a pas de r√©ponse pour ce tour de jeu.")
        } else {
          sujet = new Intitule(contexteTour.reponse.toString(), PhraseUtils.getGroupeNominalDefiniOuIndefini(contexteTour.reponse.toString(), false), ClassesRacines.Intitule);
        }
        // r√®gle
      } else if (conditionSujetNomNettoye === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('r√®gle')) {
        if (!declenchements) {
          console.warn("siEstVraiSansLien: r√®gle: il ne s‚Äôagit pas d‚Äôune r√®gle (¬´ d√©clenchements ¬ª pas d√©fini).");
        } else {
          const cpt = new Compteur("d√©clenchements r√®gle", declenchements);
          sujet = cpt;
        }
        // action (c‚Äôest √† dire l‚Äôaction li√©e √† l‚Äô√©v√©nement)
        // => infinitif
      } else if (conditionSujetNomNettoye.match(/infinitif (?:de l(?:'|‚Äô))?action/i)) {
        sujet = new Intitule(evenement.infinitif, new GroupeNominal(null, evenement.infinitif, null), ClassesRacines.Intitule);

        // sortie/obstacle/porte vers ceci/cela
      } else if (conditionSujetNomNettoye.match(/(sortie|obstacle|porte) vers/i)) {
        let locString: string = condition.sujet.epithete;
        if (condition.sujet.epithete == 'ceci') {
          locString = contexteTour.ceci.intitule.nom;
        } else if (condition.sujet.epithete == 'cela') {
          locString = contexteTour.cela.intitule.nom;
        }
        const loc = ElementsJeuUtils.trouverLocalisation(new GroupeNominal(null, locString));

        if (loc == null) {
          console.error("siEstVraiSansLien: sortie/porte vers '", sujet.intitule.nom, "': direction inconnue.");
          // regarder s'il y a une sortie dans la direction indiqu√©e
        } else {
          // sortie vers
          if (conditionSujetNomNettoye.startsWith("sortie")) {
            const voisinID = this.eju.getVoisinDirectionID(loc, EClasseRacine.lieu);
            if (voisinID !== -1) {
              sujet = this.eju.getLieu(voisinID);
            }
            // porte vers
          } else if (conditionSujetNomNettoye.startsWith("porte")) {
            const porteID = this.eju.getVoisinDirectionID(loc, EClasseRacine.porte);
            if (porteID !== -1) {
              sujet = this.eju.getObjet(porteID);
            }
            // obstacle vers
          } else {
            const obstacleID = this.eju.getVoisinDirectionID(loc, EClasseRacine.obstacle);
            if (obstacleID !== -1) {
              sujet = this.eju.getObjet(obstacleID);
            }
          }
        }
        // horloge
      } else if ((ExprReg.oHorloge).test(conditionSujetNomNettoye)) {
        sujet = this.getValeurHorloge(conditionSujetNomNettoye, condition.verbe);
        // calendrier
      } else if ((ExprReg.oCalendrier).test(conditionSujetNomNettoye)) {
        sujet = this.getValeurCalendrier(conditionSujetNomNettoye, condition.verbe);
      } else {
        // chercher dans les valeurs
        const valeurTrouvee = contexteTour?.trouverValeur(condition.sujet.nomEpithete);

        // valeur
        if (valeurTrouvee) {

          switch (typeof valeurTrouvee) {
            // texte
            // TODO: texte plut√¥t que intitul√©
            case 'string':
              sujet = new Intitule(valeurTrouvee, new GroupeNominal(null, valeurTrouvee, null), ClassesRacines.Intitule);
              break;

            // nombre
            case 'number':
              sujet = new Compteur('valeur', valeurTrouvee)
              break

            // intiutl√©
            default:
              sujet = valeurTrouvee;
              break;
          }
          // pas une valeur
        } else {
          const correspondances = this.eju.trouverCorrespondance(condition.sujet, TypeSujet.SujetEstNom, false, false);
          if (correspondances.elements.length == 1) {
            sujet = correspondances.elements[0];
          } else if (correspondances.elements.length > 1 || correspondances.compteurs.length > 1) {
            console.error("siEstVraiSansLien >>> plusieurs √©l√©ments trouv√©s pour le sujet:", condition.sujet, condition, correspondances);
          } else if (correspondances.compteurs.length === 1) {
            sujet = correspondances.compteurs[0];
          } else if (correspondances.listes.length === 1) {
            sujet = correspondances.listes[0];
          } else {
            // chercher dans les propri√©t√©s
            const proprieteJeu = PhraseUtils.trouverPropriete(condition.sujet.toString());
            if (proprieteJeu) {
              const proprieteCible = InstructionsUtils.trouverProprieteCible(proprieteJeu, contexteTour, this.eju, this.jeu);
              if (proprieteCible instanceof Compteur) {
                sujet = proprieteCible;
              } else {
                if (proprieteCible.type == TypeValeur.nombre) {
                  sujet = CompteursUtils.proprieteElementVersCompteur(proprieteCible);
                } else {
                  sujet = new Intitule(proprieteCible.valeur, null, ClassesRacines.Intitule);
                }
              }
              // le jeu n‚Äôest pas dans les objets mais il est g√©r√© plus loin
            } else if (conditionSujetNomNettoye == 'jeu' && !condition.sujet.epithete) {
              // le tirage n'est pas un objet, mais il est g√©r√© plus loin
            } else if (conditionSujetNomNettoye == 'tirage' && !condition.sujet.epithete) {
              // rien √† dire ici
            } else {
              console.error("siEstVraiSansLien >>> pas d‚Äô√©l√©ment trouv√© pour pour le sujet:", condition.sujet, condition, correspondances);
              contexteTour.ajouterErreurCondition(condition, `Sujet de la condition pas trouv√©‚ÄØ: ${condition.sujet}`);
            }
          }
        }
      }
    }
    return sujet;
  }

  /**
   * Tester si la condition est vraie.
   * Remarque: le LIEN (et/ou/soit) n'est PAS TEST√â. La m√©thode siEstVraiAvecLiens le fait.
   */
  public siEstVraiSansLien(conditionString: string | undefined, condition: ConditionSolo | undefined, contexteTour: ContexteTour, evenement: Evenement | undefined, declenchements: number | undefined) {

    let retVal = false;
    // si condition toujours brute, r√©cup√©rer la condition correspondante.
    if (!condition) {
      condition = AnalyseurCondition.getConditionMulti(conditionString)?.condition;
    }

    if (condition) {
      // 1 - Trouver le sujet
      // ++++++++++++++++++++
      let sujet = this.trouverSujetCondition(condition, contexteTour, evenement, declenchements);

      // *********************************************
      //  A. √âL√âMENT DU JEU
      // *********************************************
      if (sujet && ClasseUtils.heriteDe(sujet.classe, EClasseRacine.element)) {

        // 2 - Trouver le verbe
        // ++++++++++++++++++++
        switch (condition.verbe) {
          // √âTAT
          case 'est':
          case 'sont':
            // remarque: n√©gation appliqu√©e plus loin.
            if (condition.complement?.startsWith('d√©fini')) {
              retVal = true;
            } else {
              // est une [classe] | est [√©tat]
              // remarque: n√©gation appliqu√©e plus loin.
              retVal = this.verifierConditionEst(condition, (sujet as ElementJeu));
            }
            break;

          // CONTENU
          case 'contient':
          case 'contiennent':
          case 'inclut':
          case 'incluent':
            // remarque: n√©gation appliqu√©e plus loin.
            if (condition.sujetComplement &&
              condition.sujetComplement.determinant?.match(/un |des |d'|d‚Äô/i) &&
              condition.sujetComplement.nom.match(/objet(s)?/i)
            ) {
              retVal = this.eju.verifierContientObjet(sujet as ElementJeu);
            } else if (condition.sujetComplement && condition.sujetComplement.nom === 'aucun' && condition.sujetComplement.epithete?.match(/objet(s)?/i)) {
              retVal = !this.eju.verifierContientObjet(sujet as ElementJeu);
            } else {
              contexteTour.ajouterErreurCondition(condition, `siEstVraiSansLien > condition ¬´ contient ¬ª pas encore g√©r√©e pour le compl√©ment ${condition.complement}`)
            }
            break;


          // EXISTANCE
          // forme "aucun¬∑e xxxx pour yyyy" ou "aucun¬∑e xxx vers yyyy"
          // Ex: aucune description n‚Äôexiste pour ceci. 
          // Ex: aucune sortie n‚Äôexiste vers le nord.
          // Ex: un aper√ßu existe pour cela.
          case 'existe':
            retVal = this.verifierConditionExiste(condition, sujet, contexteTour, evenement, declenchements);
            break;

          // √âL√âMENT POSS√âD√â (PAR LE JOUEUR)
          case 'poss√®de':
            if (sujet.nom === "joueur") {
              // v√©rifier si l‚Äôobjet cible est poss√©d√© par le joueur
              // > remarque: n√©gation appliqu√©e plus loin.
              const objetCible = this.trouverObjetCible(condition.complement, condition.sujetComplement, contexteTour);
              if (objetCible) {
                retVal = this.jeu.etats.possedeEtatIdElement(objetCible, this.jeu.etats.possedeID);
              }
              break;
            } else {
              console.error("siEstVraiSansLien > condition ¬´ poss√®de ¬ª prise en charge uniquement pour le joueur.");
            }
            break;


          // √âL√âMENT PORT√â (PAR LE JOUEUR)
          case 'porte':
            if (sujet.nom.toLowerCase() === "joueur") {
              // v√©rifier si l‚Äôobjet cible est port√© par le joueur
              // > remarque: n√©gation appliqu√©e plus loin.
              const objetCible = this.trouverObjetCible(condition.complement, condition.sujetComplement, contexteTour);
              if (objetCible) {
                retVal = this.jeu.etats.possedeEtatIdElement(objetCible, this.jeu.etats.porteID);
              }
              break;
            } else {
              console.error("siEstVraiSansLien > condition ¬´ porte ¬ª prise en charge uniquement pour le joueur.", sujet.nom);
            }
            break;

          // LOCALISATION
          case 'se trouve':
          case 'se trouvent':
            // retrouver la destination
            // remarque: n√©gation appliqu√©e plus loin.
            let destination: ElementJeu = null;

            const conditionSujetComplementNomNettoye = RechercheUtils.transformerCaracteresSpeciauxEtMajuscules(condition.sujetComplement?.nom);


            if (condition.sujetComplement?.nom === "ici") {
              destination = this.eju.curLieu;
            } else if (condition.sujetComplement?.nom === "ceci") {
              if (contexteTour.ceci && ClasseUtils.heriteDe(contexteTour.ceci.classe, EClasseRacine.lieu)) {
                destination = contexteTour.ceci as Lieu;
                // (la commande aller passe par ici avec une direction)
              } else if (!contexteTour.ceci || !ClasseUtils.heriteDe(contexteTour.ceci.classe, EClasseRacine.direction)) {
                console.error("siEstVraiSansLien > condition se trouve dans ceci: ceci n‚Äôest pas un lieu ceci=", contexteTour.ceci);
              }
            } else if (condition.sujetComplement?.nom === "cela") {
              if (contexteTour.cela && ClasseUtils.heriteDe(contexteTour.cela.classe, EClasseRacine.lieu)) {
                destination = contexteTour.cela as Lieu;
                // (la commande aller passe par ici avec une direction)
              } else if (!contexteTour.cela || !ClasseUtils.heriteDe(contexteTour.cela.classe, EClasseRacine.direction)) {
                console.error("siEstVraiSansLien > condition se trouve dans cela‚ÄØ: cela n‚Äôest pas un lieu cela=", contexteTour.cela);
              }
              // origine
            } else if (conditionSujetComplementNomNettoye === 'origine') {
              destination = contexteTour.origine;
              if (!contexteTour.origine) {
                console.warn("siEstVraiSansLien: le ¬´ origine ¬ª de la condition est null.");
              }
              // destination
            } else if (conditionSujetComplementNomNettoye === 'destination') {
              destination = contexteTour.destination;
              if (!contexteTour.destination) {
                console.warn("siEstVraiSansLien: le ¬´ destination ¬ª de la condition est null.");
              }
              //   // orientation
              // } else if (conditionSujetComplementNomNettoye === 'orientation') {
              //   destination = contexteTour.orientation;
              //   if (!contexteTour.orientation) {
              //     console.warn("siEstVraiSansLien: le ¬´ orientation ¬ª de la condition est null.");
              //   }
            } else {
              const correspondances = this.eju.trouverCorrespondance(condition.sujetComplement, TypeSujet.SujetEstNom, false, false);
              if (correspondances.nbCor === 1) {
                destination = correspondances.elements[0];
              } else if (correspondances.nbCor === 0) {
                console.error("siEstVraiSansLien > condition se trouve: pas de correspondance trouv√©e pour dest=", condition.sujetComplement);
              } else if (correspondances.nbCor > 1) {
                console.error("siEstVraiSansLien > condition se trouve: plusieurs correspondances trouv√©es pour dest=", condition.sujetComplement, "cor=", correspondances);
              }
            }

            // si on a trouv√© la cible et la destination
            // TODO: destination pourrait √™tre un objet ou une direction !
            if (sujet && destination) {
              // v√©rifier que la cible se trouve au bon endroit
              if ((sujet as Objet).position.cibleId === destination.id) {
                retVal = true;
              }
            }
            break;

          case 'r√©agit':
          case 'r√©agissent':
            // remarque: n√©gation appliqu√©e plus loin.
            if ((sujet as Objet).reactions && (sujet as Objet).reactions.length > 0) {
              retVal = true;
            }
            break;

          // comparaison : √©galit√©
          case 'valent':
          case 'vaut':
            // TODO: g√©rer plus de situations (en test)
            // remarque: n√©gation appliqu√©e plus loin.

            // console.warn("vaut condi=", condition, "ceci=", contexteTour.ceci, "cela=", contexteTour.cela);

            if (('"' + sujet.nom + '"') === condition.complement) {
              retVal = true;
            }
            break;

          // comparaison : commence par
          case 'commence':
            if (sujet.nom.startsWith(condition.complement.replace(/^\"|\"$/g, ''))) {
              retVal = true;
            }
            break;

          // comparaison : termine par
          case 'termine':
            if (sujet.nom.endsWith(condition.complement.replace(/^\"|\"$/g, ''))) {
              retVal = true;
            }
            break;

          default:
            console.error(
              "siEstVraiSansLien > Condition √©l√©ment du jeu: verbe pas connu (" + condition.verbe + ").\n",
              "Les verbes connus sont : √™tre, contenir, exister, poss√©der, porter, se trouver, r√©agir et valoir.\n",
              condition);
            break;
        }
        // *********************************************
        //  B. COMPTEUR
        // *********************************************
      } else if (sujet && ClasseUtils.heriteDe(sujet.classe, EClasseRacine.compteur)) {

        const compteur = sujet as Compteur;

        // 2 - Trouver le verbe
        // ++++++++++++++++++++
        switch (condition.verbe) {

          case 'est':
          case 'sont':
            // remarque: n√©gation appliqu√©e plus loin.
            if (condition.complement?.startsWith('d√©fini')) {
              retVal = true;
            } else {
              console.error("Condition compteur: est: support√© seulement pour ¬´‚ÄØd√©fini‚ÄØ¬ª");
            }
            break;

          // comparaison : √©gal (vaut) ‚àí diff√©rent (ne vaut pas)
          case 'valent':
          case 'vaut':
            // remarque: n√©gation appliqu√©e plus loin.
            retVal = compteur.valeur === CompteursUtils.intituleValeurVersNombre(condition.complement, contexteTour, evenement, this.eju, this.jeu);
            break;

          // comparaison:‚ÄØplus grand que (d√©passe) - plus petit ou √©gal (ne d√©passe pas)
          case 'd√©passe':
          case 'd√©passent':
            // remarque: n√©gation appliqu√©e plus loin.
            retVal = compteur.valeur > CompteursUtils.intituleValeurVersNombre(condition.complement, contexteTour, evenement, this.eju, this.jeu);
            break;

          // comparaison:‚ÄØplus grand ou √©gal (atteint) ‚àí plus petit que (n‚Äôatteint pas)
          case 'atteint':
          case 'atteignent':
            // remarque: n√©gation appliqu√©e plus loin.
            retVal = compteur.valeur >= CompteursUtils.intituleValeurVersNombre(condition.complement, contexteTour, evenement, this.eju, this.jeu);
            break;

          case 'se d√©clenche':
            // remarque: n√©gation appliqu√©e plus loin.
            if (compteur.nom === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('d√©clenchements r√®gle') && condition.complement === 'pour la premi√®re fois') {
              retVal = (compteur.valeur === 1);
            } else if (compteur.nom === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('d√©clenchements r√®gle') && condition.complement === 'pour la deuxi√®me fois') {
              retVal = (compteur.valeur === 2);
            } else if (compteur.nom === RechercheUtils.transformerCaracteresSpeciauxEtMajuscules('d√©clenchements r√®gle') && condition.complement === 'pour la troisi√®me fois') {
              retVal = (compteur.valeur === 3);
            } else {
              console.error("Condition compteur: d√©clenche: support√© seulement pour ¬´ la r√®gle se d√©clenche pour la premi√®re fois.");
            }
            break;

          default:
            console.error(
              "Condition compteur: verbe pas connu (" + condition.verbe + ").\n",
              "Les verbes connus sont : valoir, d√©ppasser et atteindre.\n",
              condition);
            break;

        }
        // *********************************************
        //  C. LISTE
        // *********************************************
      } else if (sujet && ClasseUtils.heriteDe(sujet.classe, EClasseRacine.liste)) {

        const liste = sujet as Liste;

        // 2 - Trouver le verbe
        // ++++++++++++++++++++
        switch (condition.verbe) {

          case 'est':
          case 'sont':
            // remarque: n√©gation appliqu√©e plus loin.
            if (condition.complement == 'vide' || condition.complement == 'vides') {
              retVal = liste.vide;
            } else if (condition.complement?.startsWith('d√©fini')) {
              retVal = true;
            } else {
              console.error("Condition liste: est: support√© seulement pour ¬´‚ÄØvide‚ÄØ¬ª et ¬´‚ÄØd√©fini‚ÄØ¬ª");
            }
            break;

          case 'contient':
          case 'contiennent':
          case 'inclut':
          case 'incluent':
            // remarque: n√©gation appliqu√©e plus loin.
            if (condition.complement) {
              // A. NOMBRE
              if (condition.complement.match(ExprReg.xNombreEntier)) {
                retVal = liste.contientNombre(Number.parseInt(condition.complement));
              } else if (condition.complement.match(ExprReg.xNombreDecimal)) {
                retVal = liste.contientNombre(Number.parseFloat(condition.complement));
                // B. INTITUL√â
              } else if (condition.sujetComplement) {
                let intitule: Intitule;
                // i) rechercher parmi les cibles sp√©ciales (ceci, cela, ‚Ä¶)
                const cibleSpeciale: Intitule = InstructionsUtils.trouverCibleSpeciale(condition.sujetComplement.nom, contexteTour, evenement, this.eju, this.jeu);
                if (cibleSpeciale) {
                  intitule = cibleSpeciale;
                  // ii) rechercher parmis tous les √©l√©ments du jeu
                } else {
                  const cor = this.eju.trouverCorrespondance(condition.sujetComplement, TypeSujet.SujetEstNom, false, false);
                  if (cor.nbCor == 1) {
                    intitule = cor.unique;
                  } else {
                    intitule = cor.intitule;
                  }
                }
                retVal = liste.contientIntitule(intitule);
                // C. TEXTE
              } else {
                retVal = liste.contientTexte(condition.complement);
              }
            } else {
              this.jeu.tamponErreurs.push('Condition "liste contient": il manque un compl√©ment. (' + (conditionString ? conditionString : condition.toString()) + ')')
            }

            break;

          default:
            console.error(
              "Condition liste: verbe pas connu (" + condition.verbe + ").\n",
              "Les verbes connus sont : √™tre.\n",
              condition);
            break;

        }
        // *********************************************
        //  C. DIRECTION
        // *********************************************
      } else if (sujet && ClasseUtils.heriteDe(sujet.classe, EClasseRacine.direction)) {

        // 2 - Trouver le verbe
        // ++++++++++++++++++++
        switch (condition.verbe) {

          case 'est':
            // est une [classe] | est [√©tat]
            // remarque: n√©gation appliqu√©e plus loin.
            retVal = this.verifierConditionEst(condition, (sujet as Intitule));
            break;

          // EXISTANCE
          // forme "aucun¬∑e xxxx pour yyyy" ou "aucun¬∑e xxx vers yyyy"
          // Ex: aucune description n‚Äôexiste pour ceci. 
          // Ex: aucune sortie n‚Äôexiste vers le nord.
          // Ex: un aper√ßu existe pour cela.
          case 'existe':
            retVal = this.verifierConditionExiste(condition, sujet, contexteTour, evenement, declenchements);
            break;

          // comparaison : √©galit√©
          case 'valent':
          case 'vaut':
            // remarque: n√©gation appliqu√©e plus loin.
            if (('"' + sujet.nom + '"') === condition.complement) {
              retVal = true;
            }
            break;



          default:
            console.error(
              "Condition intitul√©: verbe pas connu (" + condition.verbe + ").\n",
              "Les verbes connus sont : valoir.\n",
              condition);
            break;
        }

        // *********************************************
        //  D. INTITUL√â
        // *********************************************
      } else if (sujet && ClasseUtils.heriteDe(sujet.classe, EClasseRacine.intitule)) {

        // 2 - Trouver le verbe
        // ++++++++++++++++++++
        switch (condition.verbe) {

          case 'est':

            // remarque: n√©gation appliqu√©e plus loin.
            if (condition.complement?.startsWith('d√©fini')) {
              retVal = true;
            } else {
              // est une [classe] | est [√©tat]
              // remarque: n√©gation appliqu√©e plus loin.
              retVal = this.verifierConditionEst(condition, (sujet as Intitule));
            }

            break;

          // comparaison : √©galit√©
          case 'valent':
          case 'vaut':
            // remarque: n√©gation appliqu√©e plus loin.
            if (condition.sujetComplement) {
              if (sujet.intitule.nom == condition.sujetComplement.nom && (sujet.intitule.epithete == condition.sujetComplement.epithete)) {
                retVal = true;
              }
            } else if (sujet.intitule.toString() == condition.complement) {
              retVal = true;
            }
            break;

          // comparaison: commence par
          case 'commence':
            retVal = sujet.intitule.toString().startsWith(condition.complement.replace(/^\"|\"$/g, ''));
            break;

          // comparaison: termine par
          case 'termine':
            retVal = sujet.intitule.toString().endsWith(condition.complement.replace(/^\"|\"$/g, ''));
            break;

          case 'existe':
            if (condition.complement = 'pr√©position') {
              if (condition.sujet.nom == 'ceci') {
                // remarque: n√©gation appliqu√©e plus loin.
                if (evenement.prepositionCeci) {
                  retVal = true;
                }
              } else if (condition.sujet.nom == 'cela') {
                // remarque: n√©gation appliqu√©e plus loin.
                if (evenement.prepositionCela) {
                  retVal = true;
                }
              } else {
                console.error("Seul ceci/cela sont pris en charge pour la formulation ¬´ (auc)une pr√©position (n‚Äô)existe pour ¬ª.");
              }
            } else {
              console.error("Seul ¬´ pr√©position ¬ª pris en charge pour la formulation ¬´ (auc)une pr√©position (n‚Äô)existe pour ¬ª.");
            }
            break;

          default:
            console.error(
              "Condition intitul√©: verbe pas connu (" + condition.verbe + ").\n",
              "Les verbes connus sont : valoir.\n",
              condition);
            break;

        }
        // *********************************************
        //  D. AUCUN SUJET
        // *********************************************
      } else {

        // condition sp√©ciale: le jeu est commenc√©
        // remarque: n√©gation appliqu√©e plus loin.
        if (condition.sujet.nomEpithete == 'jeu' && condition.verbe == 'est' && condition.complement == 'commenc√©') {
          if (this.jeu.commence) {
            retVal = true;
          }
          // condition sp√©ciale: le jeu est commenc√©
          // remarque: n√©gation appliqu√©e plus loin.
        } else if (condition.sujet.nomEpithete == 'jeu' && condition.verbe == 'est' && condition.complement == 'termin√©') {
          if (this.jeu.termine) {
            retVal = true;
          }
          // condition sp√©ciale : tirage √† X chance sur Y r√©ussit
          // remarque: n√©gation appliqu√©e plus loin.
        } else if (condition.sujet.nomEpithete == 'tirage') {
          // le seul verbe autoris√© pour un tirage est 'r√©ussit'
          if (condition.verbe == 'r√©ussit') {
            const motsClesComplement = condition.complement.split(' ');
            if (motsClesComplement.length == 4 && motsClesComplement[1].startsWith('chance') && motsClesComplement[2] == 'sur') {
              const nbChance = Number.parseInt(motsClesComplement[0]);
              const totalTirage = Number.parseInt(motsClesComplement[3]);
              if (nbChance > 0 && totalTirage > 0 && nbChance <= totalTirage) {
                const rand = AleatoireUtils.nombre();
                const ratio = (1 - (nbChance / totalTirage));
                if (rand >= ratio) {
                  retVal = true;
                } else {
                  retVal = false;
                }
              } else {
                this.jeu.tamponErreurs.push("condition ¬´‚ÄØun tirage √† x chances sur y‚ÄØ¬ª‚ÄØ: x et y doivent √™tre sup√©rieurs √† 0, x ne peut pas d√©passer y.");
              }
            } else {
              this.jeu.tamponErreurs.push("condition ¬´‚ÄØun tirage √† x chances sur y‚ÄØ¬ª‚ÄØ: formulation pas support√©e: ", condition.toString());
            }
          } else {
            this.jeu.tamponErreurs.push("condition sur un tirage‚ÄØ: seuls les verbes '√©chouer' et 'r√©ussir' sont pris en charge.");
          }
          // rien trouv√© comme sujet
        } else {
          // si le verbe est "√™tre", on retourne toujours faux, puisqu‚Äôun √©l√©ment ind√©fini n‚Äôest pas.
          if (condition.verbe == 'est' || condition.verbe == 'sont') {
            retVal = false;
            console.log("Pas d√©fini donc.");
            if (!condition.complement?.startsWith('d√©fini')) {
              this.jeu.tamponConseils.push("le sujet de la condition n‚Äô√©tant pas d√©fini, le r√©sultat est faux: si " + condition + " (" + condition.sujet + ")");
            }
          } else {
            this.jeu.tamponErreurs.push("le sujet de la condition n‚Äôest pas d√©fini, le r√©sultat est faux: si " + condition + " (" + condition.sujet + ")");
          }
        }
      }

    } else {
      console.error("siEstVraiSansLien > condition pas comprise:", condition);
    }

    if (this.verbeux) {
      console.log("siEstVraiSansLien > ", condition, retVal);
    }
    // prise en compte de la n√©gation
    if (condition.negation) {
      retVal = !retVal;
    }

    // // -------------------------------------------------------
    // // DEB: Affichage d√©taill√© de la condition et du retour
    // // -------------------------------------------------------
    // console.warn(
    //   "Condition:",
    //   "\n Suj:", ((condition.sujet?.nom ?? "") + " " + (condition.sujet?.epithete ?? "")),
    //   ((condition.sujet ? (condition.sujet.nom === 'ceci' ? ("(" + (ceci?.nom ?? '-') + ")") : '') : '') +
    //   (condition.sujet ? (condition.sujet.nom === 'cela' ? ("(" + (cela?.nom ?? '-') + ")") : '') : '') +
    //   (condition.sujet ? (condition.sujet.nom === 'ici' ? ("(" + this.eju.curLieu.nom + ")") : '') : '')),
    //   "\n Ver:", condition.verbe,
    //   "\n Neg:", (condition.negation ?? "‚àí"),
    //   "\n Com:", ((condition.sujetComplement?.nom ?? "") + " " + (condition.sujetComplement?.epithete ?? "")),
    //   "\n >>> ", retVal);

    return retVal;
  }

  /**
   * Retrouver l‚Äôobjet cible de la condition.
   * @param brute ¬´ ceci ¬ª et ¬´ cela ¬ª sont g√©r√©s.
   * @param intitule un objet √† retrouver
   * @param ceci pour le cas o√π brute vaut ¬´ ceci ¬ª.
   * @param cela pour le cas o√π brute vaut ¬´ cela ¬ª.
   */
  private trouverObjetCible(brute: string, intitule: GroupeNominal, contexteTour: ContexteTour): Objet {
    let objetCible: Objet = null;

    const bruteNettoye = RechercheUtils.transformerCaracteresSpeciauxEtMajuscules(brute);

    // retrouver OBJET SP√âCIAL
    if (bruteNettoye === 'ceci') {
      if (contexteTour.ceci && ClasseUtils.heriteDe(contexteTour.ceci.classe, EClasseRacine.objet)) {
        objetCible = contexteTour.ceci as Objet;
      } else {
        console.error("ConditionsUtils > trouverObjetCible > ceci n‚Äôest pas un objet.");
      }
    } else if (bruteNettoye === 'cela') {
      if (contexteTour.cela && ClasseUtils.heriteDe(contexteTour.cela.classe, EClasseRacine.objet)) {
        objetCible = contexteTour.cela as Objet;
      } else {
        console.error("ConditionsUtils > trouverObjetCible > cela n‚Äôest pas un objet.");
      }
    } else {
      // retrouver OBJET CLASSIQUE
      if (intitule) {
        const objetsTrouves = this.eju.trouverObjet(intitule, false);
        if (objetsTrouves.length == 1) {
          objetCible = objetsTrouves[0];
        } else if (objetsTrouves.length != 0) {
          console.warn("Instructions > trouverObjetCible > plusieurs correspondances trouv√©es pour‚ÄØ:", brute);
        }
        // retrouver OBJET SP√âCIAL
      } else {
        console.error("ConditionsUtils > trouverObjetCible > objet sp√©cial pas pris en change‚ÄØ:", brute);
      }
    }

    if (!objetCible) {
      console.warn("ConditionsUtils > trouverObjetCible > pas pu trouver‚ÄØ:", brute);
    }

    return objetCible;
  }

  /** 
 * V√©rifier une condition de type "est", c'est √† dire v√©rifer l'√©tat ou la classe.
 * /!\ La n√©gation n'est pas appliqu√©e ici, il faut le faire ensuite.
 */
  private verifierConditionEst(condition: ConditionSolo, sujet: ElementJeu | Intitule) {
    let resultCondition: boolean = null;

    if (!condition.sujetComplement || !condition.sujetComplement.determinant) {
      // v√©rifier la liste des √©tats (si c‚Äôest un √©l√©mentJeu)
      if (ClasseUtils.heriteDe(sujet.classe, EClasseRacine.element)) {
        resultCondition = this.jeu.etats.possedeEtatElement((sujet as ElementJeu), condition.complement, this.eju);
        // sinon comparer l‚Äôintitul√© du sujet avec le compl√©ment
      } else if (ClasseUtils.heriteDe(sujet.classe, EClasseRacine.intitule)) {
        resultCondition = (sujet.intitule.toString() == condition.complement);
      } else {
        console.error("verbe ¬´‚ÄØest‚ÄØ¬ª utilis√© sur un type non support√©.");
        resultCondition = false;
      }
    } else {
      switch (condition.sujetComplement.determinant) {
        case "un ":
        case "une ":
        case "des ":
        case "de la ":
        case "du ":
        case "de l‚Äô":
        case "de l'":
          resultCondition = ClasseUtils.heriteDe(sujet.classe, condition.sujetComplement.nom);
          break;

        case "la ":
        case "le ":
        case "l‚Äô":
        case "l'":
        case "les ":
          resultCondition = (sujet.intitule.nom === condition.sujetComplement.nom) && (sujet.intitule.epithete === condition.sujetComplement.epithete);
          // si le compl√©ment est un groupe nominal, v√©rifier √©galement les synonymes du sujet
          if (!resultCondition && ClasseUtils.heriteDe(sujet.classe, EClasseRacine.element)) {
            if ((sujet as ElementJeu).synonymes?.length) {
              (sujet as ElementJeu).synonymes.forEach(syn => {
                if (!resultCondition && (syn.nom === condition.sujetComplement.nom) && (syn.epithete === condition.sujetComplement.epithete)) {
                  resultCondition = true;
                }
              });
            }
          }
          break;

        default:
          console.error("verifierConditionEst : d√©terminant pas g√©r√©:", condition.sujetComplement.determinant);
          resultCondition = false;
          break;
      }
    }

    return resultCondition;

  }

  private verifierConditionExiste(condition: ConditionSolo, sujet: ElementJeu | Intitule, contexteTour: ContexteTour, evenement: Evenement, declenchements: number) {

    let retVal = false;

    // remarque: n√©gation appliqu√©e plus loin.
    // A) SORTIE
    if (condition.sujetComplement.nom === 'sortie') {
      // console.warn("Test des sorties", condition, sujet);
      // trouver direction
      let loc: Localisation | ELocalisation = null;
      // si le sujet est un lieu
      if (ClasseUtils.heriteDe(sujet.classe, EClasseRacine.lieu)) {
        // chercher la direction vers ce lieu
        let voisin = this.eju.curLieu.voisins.find(x => x.type == EClasseRacine.lieu && x.id == (sujet as Lieu).id);
        loc = voisin.localisation;
        // sinon c‚Äôest directement une direction
      } else {
        loc = ElementsJeuUtils.trouverLocalisation(sujet.intitule);
      }
      if (loc == null) {
        console.error("siEstVraiSansLien: sorties vers '", sujet.intitule.nom, "': direction inconnue.");
        // regarder s'il y a une sortie dans la direction indiqu√©e
      } else {
        let voisinID = this.eju.getVoisinDirectionID(loc, EClasseRacine.lieu);
        // cas particulier : si le joueur utilise entrer/sortir quand une seule sortie visible, aller dans la direction de cette sortie
        if (loc instanceof Localisation && (loc.id == ELocalisation.exterieur /*|| loc.id == ELocalisation.interieur*/)) {
          const lieuxVoisinsVisibles = this.eju.getLieuxVoisinsVisibles(this.eju.curLieu);
          if (lieuxVoisinsVisibles.length == 1) {
            voisinID = lieuxVoisinsVisibles[0].id;
            loc = lieuxVoisinsVisibles[0].localisation;
          }
        }

        // Pas de voisin => aucune sortie dans cette direction
        if (voisinID == -1) {
          retVal = false;
          // voisin existe
        } else {
          // trouver si porte s√©pare voisin
          const porteID = this.eju.getVoisinDirectionID(loc, EClasseRacine.porte);
          // aucune porte => sortie existe et est accessible
          if (porteID == -1) {
            retVal = true;
            // une porte
          } else {
            const porte = this.eju.getObjet(porteID);
            // si on teste ¬´ existe sortie ¬ª tout court, il y a une sortie (sauf si porte invisible ferm√©e.)
            if (!condition.sujetComplement.epithete) {
              // retVal = !this.jeu.etats.possedeCesEtatsElement(porte, EEtatsBase.invisible, EEtatsBase.ferme, LienCondition.et, this.eju);
              retVal = !(!this.jeu.etats.possedeEtatIdElement(porte, this.jeu.etats.visibleID, this.eju) && this.jeu.etats.possedeEtatIdElement(porte, this.jeu.etats.fermeID, this.eju));
              // si on test ¬´ existe sortie accessible ¬ª, il faut que la porte soit ouverte pour retourner vrai.
            } else if (condition.sujetComplement.epithete == 'accessible') {
              retVal = this.jeu.etats.possedeEtatElement(porte, EEtatsBase.ouvert, this.eju);
              // attribut pas pris en charge
            } else {
              console.error("siEstVrai sorties ¬´", condition.sujetComplement.epithete, "¬ª : attribut pas pris en charge.");
              retVal = false; // => pas de sortie
            }
          }

          // s‚Äôil y a une sortie, v√©rifier qu‚Äôelle n‚Äôest pas obstru√©e par un obstacle
          if (retVal == true) {
            // trouver si obstacle (autre que porte) s√©pare voisin
            const obstacleID = this.eju.getVoisinDirectionID(loc, EClasseRacine.obstacle);
            if (obstacleID !== -1) {
              const obstacle = this.eju.getObjet(obstacleID);
              // si on teste ¬´ existe sortie ¬ª tout court, il y a une sortie (sauf si obstacle couvrant.)
              if (!condition.sujetComplement.epithete) {
                retVal = !this.jeu.etats.possedeEtatIdElement(obstacle, this.jeu.etats.couvrantID, this.eju);
                // si on test ¬´ existe sortie accessible ¬ª, c‚Äôest forc√©ment faut puisqu‚Äôil y a un obstacle.
              } else if (condition.sujetComplement.epithete == 'accessible') {
                retVal = false; // => pas de sortie accessible
                // attribut pas pris en charge
              } else {
                console.error("siEstVrai sorties ¬´", condition.sujetComplement.epithete, "¬ª : attribut pas pris en charge.");
                retVal = false; // => pas de sortie
              }
            }
          }
        }
      }
      // B) PORTE
    } else if (condition.sujetComplement.nom === 'porte') {
      console.warn("Test des portes", condition, sujet);
      // trouver direction
      const loc = ElementsJeuUtils.trouverLocalisation(sujet.intitule);
      if (loc != null) {
        console.error("siEstVraiSansLien: porte vers '", sujet.intitule.nom, "' : direction inconnue.");
        // regarder s'il y a une porte dans la direction indiqu√©e
      } else {
        const porteID = this.eju.getVoisinDirectionID(loc, EClasseRacine.porte);
        // aucune porte
        if (porteID == -1) {
          retVal = false;
          // la porte est invisible => aucune porte
        } else {
          const porte = this.eju.getObjet(porteID);
          retVal = !this.jeu.etats.possedeEtatIdElement(porte, this.jeu.etats.invisibleID);
        }
      }
      // C) OBSTACLE (AUTRE QUE PORTE)
    } else if (condition.sujetComplement.nom === 'obstacle') {
      console.warn("Test des obstacles", condition, sujet);
      // trouver direction
      const loc = ElementsJeuUtils.trouverLocalisation(sujet.intitule);
      if (loc != null) {
        console.error("siEstVraiSansLien: obstacle vers '", sujet.intitule.nom, "' : direction inconnue.");
        // regarder s'il y a une porte dans la direction indiqu√©e
      } else {
        const obstacleID = this.eju.getVoisinDirectionID(loc, EClasseRacine.obstacle);
        // aucun obstacle
        if (obstacleID == -1) {
          retVal = false;
          // l‚Äôobstacle est invisible => aucun obstacle
        } else {
          const obstacle = this.eju.getObjet(obstacleID);
          retVal = !this.jeu.etats.possedeEtatIdElement(obstacle, this.jeu.etats.invisibleID);
        }
      }
      // D) PR√âPOSITION
    } else if (condition.complement === 'pr√©position') {
      if (condition.sujet.nom == 'ceci') {
        // remarque: n√©gation appliqu√©e plus loin.
        if (evenement.prepositionCeci) {
          retVal = true;
        }
      } else if (condition.sujet.nom == 'cela') {
        // remarque: n√©gation appliqu√©e plus loin.
        if (evenement.prepositionCela) {
          retVal = true;
        }
      } else {
        console.error("Seul ceci/cela sont pris en charge pour la formulation ¬´ (auc)une pr√©position (n‚Äô)existe pour ¬ª.");
      }
      // E) PROPRI√âT√â
      // e.1 aper√ßu
    } else if ((condition.complement === 'aper√ßu') || (condition.complement === 'apercu')) {
      // => aper√ßu dans une direction
      if (ClasseUtils.heriteDe(sujet.classe, EClasseRacine.direction)) {
        const dirSujet = sujet as Localisation;
        let voisinID = this.eju.getVoisinDirectionID(dirSujet, EClasseRacine.lieu);
        if (voisinID !== -1) {
          let voisin = this.eju.getLieu(voisinID);
          retVal = voisin.apercu ? true : false;
        } else {
          console.error("cond aper√ßu existe vers direction: voisin pas trouv√© dans cette direction.");
        }
        // => aper√ßu d‚Äôun objet
      } else {
        retVal = (sujet as ElementJeu).apercu ? true : false;
      }
      // e.2 autre
    } else {
      // √† moins qu‚Äôon ne trouve la propri√©t√© et une valeur, le retour vaudra false
      retVal = false;
      // parcourir les propri√©t√©s
      (sujet as ElementJeu).proprietes.forEach(propriete => {
        // si on a trouv√© la propri√©t√© et qu‚Äôelle a une valeur
        if (propriete.nom.toLocaleLowerCase() === condition.complement.toLowerCase() && propriete.valeur) {
          // on a trouv√© la propri√©t√© et celle-ci a une valeur
          retVal = true;
        }
      });
    }

    return retVal;
  }

  private getValeurHorloge(valeurRecherchee: string, verbe: string): Compteur | undefined {
    let retVal: Compteur | undefined;
    const match = valeurRecherchee.match(ExprReg.oHorloge);
    if (match) {
      switch (match[1]) {
        case 'heure':
          retVal = new Compteur("heure", new Date().getHours());
          break;
        case 'minute':
          retVal = new Compteur("minute", new Date().getMinutes());
          break;
        case 'seconde':
          retVal = new Compteur("seconde", new Date().getSeconds());
          break;
        default:
          this.eju.ajouterErreur("getValeurHorloge: valeurRecherchee doit √™tre en minuscules.")
          break;
      }
    }
    return retVal;
  }

  private getValeurCalendrier(valeurRecherchee: string, verbe: string): Compteur | Intitule | undefined {
    let retVal: Compteur | Intitule | undefined;
    const match = valeurRecherchee.match(ExprReg.oCalendrier);
    if (match) {
      switch (match[1]) {
        // jour de la semaine
        case 'jour':
          const indexJour = new Date().getDay();
          // valeur num√©rique (1 => 7)
          if (ExprReg.verbesCompteur.test(verbe)) {
            const jours = [7, 1, 2, 3, 4, 5, 6];
            retVal = new Compteur('jour', jours[indexJour]);
            // valeur textuelle (lundi => dimanche)
          } else {
            const jours = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeurdi', 'vendredi', 'samedi'];
            retVal = new Intitule(jours[indexJour], new GroupeNominal(null, jours[indexJour], null), ClassesRacines.Intitule);
          }
          break;
        // date du mois
        case 'date':
          retVal = new Compteur("date", new Date().getDate());
          break;
        // mois (1 => 12)
        case 'mois':
          const indexMois = new Date().getMonth();
          // valeur num√©rique (1 => 12)
          if (ExprReg.verbesCompteur.test(verbe)) {
            const mois = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
            retVal = new Compteur('mois', mois[indexMois]);
            // valeur textuelle (janvier => d√©cembre)
          } else {
            const mois = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
            retVal = new Intitule(mois[indexMois], new GroupeNominal(null, mois[indexMois], null), ClassesRacines.Intitule);
          }
          break;
        case 'ann√©e':
          retVal = new Compteur("ann√©e", new Date().getFullYear());
          break;
        default:
          this.eju.ajouterErreur("getValeurCalendrier: valeurRecherchee doit √™tre en minuscules.")
          break;
      }
    }
    return retVal;
  }

}